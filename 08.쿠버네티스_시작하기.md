# 쿠버네티스 시작하기

## 레플리카셋(Replica Set) : 일정 개수의 포드를 유지하는 컨트롤러
앞서 쿠버네티스의 기본 단위인 pod에 대해 살펴보았는데, pod가 종료되는 경우 어떻게 될까?  
일단 pod를 종료시키는 방법에 대해서 알아보자.  
```bash
kubectl delete -f nginx-pod-with-ubuntu.yaml
kubectl delete pods  my-nginx-pod
```
위와 같은 명령어를 사용하면 pod가 종료되는데, 서비스에서 pod를 사용하는 경우 외부 요인에 의해 pod가 종료되지 않도록 하는 것이 중요하다.  
이를 Replica Set을 이용해 구성하는 것이 가능하며 Replica Set는 아래와 같은 특징을 가진다.
- 정해진 수의 동일한 포드가 항상 실행되도록 관리
- 노드 장애 등의 이유로 포드를 실행할 수 없다면 다른 노드에서 포드를 다시 생성
Replica Set를 사용하면 동일한 Nginx pod를 안정적으로 여러 개 운영하는 것이 가능하며, 노드에 장애가 발생하는 경우에도 정해진 개수의 pod를 자동으로 유지해준다.

### Replica Set 사용하기
```yaml
apiVersion: apps/v1
kind: ReplicaSet
metadata:
  name: replicaset-nginx
spec:
  replicas: 3
  selector:
    matchLabels:
      app: my-nginx-pods-label
  template:
    metadata:
      name: my-nginx-pod
      labels: 
        app: my-nginx-pods-label
    spec:
      containers:
      - name: nginx
        image: nginx:latest
        ports:
        - containerPort: 80
```
yaml 파일의 내용중 spec.template를 기준으로 위쪽은 Replica Set에 대한 정의를 나타내며 아래쪽은 pod에 대한 정의를 나타낸다.  
spec.replicas에 정의된 값으로 pod가 유지될 갯수를 정의하게 된다.  

### Replica Set의 동작 원리
Replica Set을 생성하면 pod가 생성되고, Replica Set을 삭제하면 pod가 삭제되어 서로 연결된 것처럼 보이지만 실제로는 그렇지 않다.  
Replica Set과 pod는 metadata에 존재하는 label selector을 사용해 연결되는데, yaml 파일에서의 spec.selector.matchLabels.app와 spec.template.metadata.labels.app의 값으로 Replica Set과 pod가 연결된다.  
Replica Set은 spec.selector.matchLabels.app에 존재하는 값과 동일한 label을 가진 pod의 갯수를 지정한 replicas 수 만큼 유지하는 것을 목적으로 한다.  
그렇다면 같은 label을 가지는 pod가 기존에 생성되어 있는 경우는 어떻게 될까?  
Replica Set은 이 조차도 하나의 pods로 판단하여 replicas에 포함시키며, 새로 생성되는 pod는 2개가 된다.  
[313p]  
반대로 수동으로 생성된 pod를 제거하면 Replica Set은 pod를 3개 유지하기 위해 pod를 신규로 생성하여 3개의 pod를 유지한다.  

이번에는 Replica Set에 있는 spec.template.metadata.labels.app를 제거해보자.  
pod의 label이 제거되는 경우 Replica Set은 label이 없는 pod는 관리대상으로 취급하지 않게 되어 Replica Set을 제거해도 해당 pod는 삭제되지 않고 남아있게 된다.  
이를 통해 Replica Set의 목적이 무엇인지 생각해 볼 수 있는데, Replica Set의 목적은 pod의 생성이 아닌 일정한 갯수의 pod를 관리하기 위한 용도로 사용된다고 생각할 수 있다.  

### Replication Controller vs Replica Set
Replication Controller은 이전 k8s의 버전에서 사용되었다 Replica Set의 이전 버전이라고 생각하면 되며, 현재는 deprecated되어 더 이상 사용되지 않는다.  

# Deployment : Replica Set, pod의 배포 관리
앞서 k8s에서 사용하는 pod와 Replica Set에 대해서 알아보았다.  
pod와 Replica Set을 사용하여 마이크로서비스 구조의 컨테이너를 구성할 수 있을 것 같지만 실제 사용하는 경우 Deployment를 사용한다.  
Deployment는 Replica Set의 상위 개념으로 Deployment를 생성하면 이에 대응하는 Replica Set도 함께 생성된다.  
Deployment를 생성하는 yaml 파일을 통해 알아보도록 하자.  
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-nginx-deployment
spec:
  replicas: 3
  selector:
    matchLabels:
      app: my-nginx
  template:
    metadata:
      name: my-nginx-pod
      labels:
        app: my-nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.10
        ports:
        - containerPort: 80
```
해당 yaml 파일을 통해 생성된 pod와 Replica Set을 살펴보면 아래와 같다.  

### Deployment를 사용해야 하는 이유
앞서 yaml을 통해 살펴본 결과 Replica Set를 사용하는 것과 크게 다를 것이 없어 보이는데, Deployment를 사용해야 하는 이유는 무엇일까  
- Application의 업데이트와  배포를 더욱 편하게 해줌
- Deployment는 Application을 배포, 관리하는 역할로 Replica Set에 대한 업데이트 전략을 지정하는 등의 설정이 가능

예를 들어 Deployment를 통해 관리하는 Application에서 image의 version이 변경된 것을 가정해보자.  
이 때 Deployment를 배포하며 --record 옵션을 추가한다.  
다음으로 image version 변경을 위해 아래의 명령어를 실행  
```bash
kubectl set image deployment my-nginx-deployment nginx=nginx:1.11 --record
```
[320p]  
명령어를 사용한 후 replicasets를 확인하면 2개의 replicasets가 존재하는 것을 확인할 수 있는데, 이는 nginx:1.10 version의 replica set과 nginx:1.11 version의 replicas set를 뜻한다.  
앞서 설정한 --record 설정은 무엇을 나타낼까 --record는 해당 버전의 변경 사항을 기록해 두는 옵션으로 추후 롤백 등의 작업을 수행할 수 있도록 한다.  

앞서 나왔던 개념들을 정리해보면 Deployment > Replica Set > pod 순으로 점점 개념이 커지며, 각각 하위에 해당하는 개념을 관리하는 용도로 사용되는 것을 알 수 있다.  

# Service : pod를 연결하고 외부에 노출
앞서 살펴본 pod, Replica Set, Deployment를 살펴보았다.  
그렇다면 이런 오브젝트에 접근하기 위해서는 어떻게 해야할까?  
k8s에서는 Service라는 오브젝트를 통해 pod, Replica Set, Deployment에 접근할 수 있도록 설정할 수 있다.  
앞서 docker의 경우 container를 생성할 때 -p 옵션을 사용하여 외부 네트워크와 연결할 수 있었지만 k8s의 경우 해당 방법으로는 pod와 통신할 수가 없고 내부적으로 사용하는 port에 대해서만 정의가 가능하다.  
앞서 살펴본 deployment의 예를 통해 살펴보면 containerPort를 확인할 수 있는데, 여기서 지정된 80은 Nginx의 웹 port를 나타낸다.  
그러나 80 port가 앞서 이야기한 것처럼 외부 네트워크와 연결되는 port는 아니며 service 오브젝트를 사용하여 연결이 필요하다. service의 주요 기능은 다음과 같다.  
- 여러 개의 pod에 쉽게 접근할 수 있도록 고유한 도메인 이름 부여
- 여러 개의 pod에 접근할 때 요청을 분산하는 로드 밸런서 기능 수행
- 클라우드 플랫폼의 로드 밸런서, 클러스터 노드의 포트 등을 통해 pod를 외부에 노출

## Service의 종류
pod에 어떻게 접근할 것이냐에 따라 종류가 여러 개로 세분화되기 때문에 적절한 서비스 종류 선택하여 사용한다.
- ClusterIP : k8s 내부에서만 pod들에 접근할 때 사용, 외부로 pod를 노출하지 않기 때문에 k8s 클러스터 내부에서만 사용되는 pod에 적합
- NodePort : pod에 접근할 수 있는 port를 모든 노드에 동일하게 개발, 외부에서 pod에 접근할 수 있는 서비스 타입
- LoadBalancer : 클라우드 플랫폼에서 제공하는 Load Balaner를 동적으로 프로비저닝해 pod에 연결하며 NodePort와 마찬가지로 외부에서 pod에 접근할 수 있는 서비스 타입 일반적으로 AWS, GCP 등과 같은 클라우드 플랫폼 환경에서만 사용 가능

### ClusterIP
먼저 ClusterIP 서비스에 대해서 알아보도록 하자.
```yaml
apiVersion: v1
kind: Service
metadata:
  name: hostname-svc-clusterip
spec:
  ports:
    - name: web-port
      port: 8080
      targetPort: 80
  selector:
    app: webserver
  type: ClusterIP
```
ClusterIP 서비스는 위와 같은 yaml 파일 형식으로 정의할 수 있다. 주요 항목에 대해 살펴보자.
- spec.select : 이 서비스에서 어떠한 라벨을 가지는 pod에 접근할 수 있게 만들지는 결정한다.  
- spec.ports.port : 생성된 서비스는 k8s 내부에서만 사용할 수 있는 고유한 IP를 할당받는데 여기서 정의된 port를 사용해 서비스의 IP에 접근할 때 사용하는 port를 정의
- spec.ports.targetPort : selector 항목에서 정의한 라벨에 의해 접근 대상이 된 pod들이 내부적으로 사용하고 있는 port를 입력 앞서 deployment-hostname.yaml에서 containerPort를 80으로 설정했기 때문에 같은 값을 사용  
- spec.type : 서비스의 type에 대해 정의하며, 앞서 살펴본 ClusterIP, NodePort, LoadBalance를 선택할 수 있다.

생성된 service 확인
```bash
kubectl get service
kubectl get svc
```
